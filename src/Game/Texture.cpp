#include "Texture.hpp"

#include <stdexcept>

using Gigi::Image;

uint8_t smiley_data[] = {
		0x08, 0x08, 0x02, 0x01, 0x02,
		0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02,
		0x02, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x02,
		0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
		0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x00, 0x01, 0x00,
		0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,
		0x02, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x02,
		0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02
};

Image Image::Smiley = Image(smiley_data, 95);

Image::Image(uint8_t* data8b, size_t size) {
	pixelsSize = size;
	try {
		processImageData(data8b);
	}
	catch (const std::out_of_range& err) { // imposta texture default in caso di errore
		processImageData(smiley_data);
	}
}

void Image::processImageData(uint8_t* data) {
	width = data[0] + 1;
	height = data[1] + 1;

	paletteSize = data[2] + 1;

	alpha = (bool)data[3];
	alphaColor = data[4];

	pixels = (uint8_t*)malloc(width * height);

	for (int i = 5; i < 5 + width * height; i++) {
		pixels[i - 5] = data[i];
	}
}